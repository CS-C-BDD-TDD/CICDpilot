class Vulnerability < ActiveRecord::Base

  has_many :stix_markings, primary_key: :guid, as: :remote_object, dependent: :destroy
  accepts_nested_attributes_for :stix_markings, allow_destroy: true

  has_many :isa_marking_structures, primary_key: :stix_id, through: :stix_markings
  has_many :isa_assertion_structures, primary_key: :stix_id, through: :stix_markings

  has_many :exploit_target_vulnerabilities, primary_key: :guid, foreign_key: :vulnerability_guid
  has_many :exploit_targets, through: :exploit_target_vulnerabilities
  has_many :stix_packages, through: :exploit_targets

  has_many :badge_statuses, primary_key: :guid, as: :remote_object, dependent: :destroy
  
  belongs_to :created_by_user, class_name: 'User', primary_key: :guid, foreign_key: :created_by_user_guid
  belongs_to :updated_by_user, class_name: 'User', primary_key: :guid, foreign_key: :updated_by_user_guid
  belongs_to :created_by_organization, class_name: 'Organization', primary_key: :guid, foreign_key: :created_by_organization_guid
  belongs_to :updated_by_organization, class_name: 'Organization', primary_key: :guid, foreign_key: :updated_by_organization_guid

  validate :validate_vulnerability_attributes

  def description=(value)
    if value.present?
      write_attribute(:description, value)
      write_attribute(:description_normalized, value.strip[0..254])
    else
      write_attribute(:description, nil)
      write_attribute(:description_normalized, nil)
    end
  end

  include AcsDefault
  include Auditable
  include Guidable
  include Ingestible
  include Serialized
  include ClassifiedObject
  include Transferable

  CLASSIFICATION_CONTAINED_BY = [:exploit_targets]

  def self.ingest(uploader, obj, parent = nil)
    x = Vulnerability.where(:osvdb_id => obj.osvdb_id, :cve_id => obj.cve_id).first if obj.osvdb_id.present? && obj.cve_id.present?
    if x.present? && uploader.overwrite == false && uploader.read_only == false
      IngestUtilities.add_warning(uploader, "Vulnerability of #{obj.osvdb_id},#{obj.cve_id} already exists.  Skipping.  Select overwrite to add")
      return x
    elsif uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite)
      if obj.osvdb_id.present? && obj.cve_id.present?
        x = Vulnerability.where(:osvdb_id => obj.osvdb_id, :cve_id => obj.cve_id)
        x = x.select{|v| v.guid.include?(Setting.READ_ONLY_EXT)}.first
      end
    end

    if x.present?
      x.stix_markings.destroy_all
    end

    if x.present? && (uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite))
      x.destroy
      x = nil
    end

    if x.blank?
      x = nil
    end

    x ||= Vulnerability.new
    x.title = obj.title
    x.description = obj.description
    x.cve_id = obj.cve_id
    x.osvdb_id = obj.osvdb_id

    if (uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite))
      if (defined? obj.guid)  
        x.guid = obj.guid + Setting.READ_ONLY_EXT
      else 
        x.guid = SecureRandom.uuid + Setting.READ_ONLY_EXT
      end
    else 
      x.guid = SecureRandom.uuid
    end
    x.stix_timestamp = obj.respond_to?(:stix_timestamp) ? obj.stix_timestamp : nil

    unless parent.nil?
      x.created_by_user_guid = parent.guid
      x.created_by_organization_guid = parent.organization_guid
      x.updated_by_user_guid = parent.guid
      x.updated_by_organization_guid = parent.organization_guid
    end

    x.read_only = uploader.read_only

    x
  rescue Exception => e
    IngestUtilities.add_warning(uploader, "Failed to build Vulnerability (#{obj.osvdb_id},#{obj.cve_id}), error #{e}")
    x
  end

  def set_controlled_structure(sm, exploit_target_id = nil)
    if sm.present?
      exploit_target_id ||= self.exploit_target_ids.first

      if exploit_target_id.blank? && self.exploit_targets.present?
        exploit_target_id = self.exploit_targets.first.stix_id
      end
      sm.controlled_structure =
          "//stixCommon:Exploit_Target[@id='#{exploit_target_id}']/" +
              'et:Vulnerability'
      xpath_segments = []
      xpath_segments << (self.title.blank? ? 'not(et:Title)' :
          "et:Title='#{self.title}'")
      xpath_segments << (self.description.blank? ? 'not(et:Description)' :
          "et:Description='#{self.description}'")
      xpath_segments << (self.cve_id.blank? ? 'not(et:CVE_ID)' :
          "et:CVE_ID='#{self.cve_id}'")
      xpath_segments << (self.osvdb_id.blank? ? 'not(et:OSVDB_ID)' :
          "et:OSVDB_ID='#{self.osvdb_id}'")
      sm.controlled_structure +=
          "[#{ xpath_segments.join(' and ') }]/"
      if sm.remote_object_field.present?
        case sm.remote_object_field
          when 'title'
            sm.controlled_structure +=
                "et:Title/"
          when 'description'
            sm.controlled_structure +=
                "et:Description/"
          when 'cve_id'
            sm.controlled_structure +=
                "et:CVE_ID/"
          when 'osvdb_id'
            sm.controlled_structure +=
                "et:OSVDB_ID/"
          else
            sm.controlled_structure = nil
            return
        end
      end
      sm.controlled_structure += 'descendant-or-self::node()'
      sm.controlled_structure += " | #{sm.controlled_structure}/@*"
    end
  end

  def validate_vulnerability_attributes
    # Relational checks for filled in fields
    if self.title.present? && self.description.blank?
      errors.add(:title, "Description cannot be blank if title is filled in.")
      return false
    elsif self.description.present? && self.title.blank?
      errors.add(:description, "Title cannot be blank if description is filled in.")
      return false
    elsif self.osvdb_id.present? && self.cve_id.blank?
      errors.add(:osvdb_id, "cve_id cannot be blank if osvdb_id is filled in.")
      return false
    elsif self.cve_id.present? && self.osvdb_id.blank?
      errors.add(:cve_id, "osvdb_id cannot be blank if cve_id is filled in.")
      return false
    end

    # Number check and positive integer
    if self.osvdb_id.present? && (self.osvdb_id =~ /\A[1-9]\d*\Z/) == nil
      errors.add(:osvdb_id, "osvdb_id must be a positive integer")
      return false
    end

    # Format check for cve_id
    if self.cve_id.present? && (self.cve_id =~ /\ACVE-\d\d\d\d-\d+\Z/) == nil
      errors.add(:cve_id, "cve_id must be in the following format CVE-<exactly four digits>-<one or more digits>")
      return false
    end

    # return true if all is good
    true
  end

  private

  searchable :auto_index => (Setting.SOLR_INDEX_FREQUENCY_IN_SECONDS||0)==0 do
    text :title
    string :title
    text :description
    string :description
    text :description_normalized
    string :description_normalized
    text :cve_id
    string :cve_id
    text :osvdb_id
    string :osvdb_id
    text :guid, as: :text_exact
    string :guid
    time :updated_at, stored: false
    time :created_at, stored: false

  end

end
