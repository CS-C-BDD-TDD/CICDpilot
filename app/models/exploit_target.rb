class ExploitTarget < ActiveRecord::Base

  has_many :stix_markings, primary_key: :guid, as: :remote_object, dependent: :destroy
  accepts_nested_attributes_for :stix_markings, allow_destroy: true
  
  has_many :isa_marking_structures, primary_key: :stix_id, through: :stix_markings
  has_many :isa_assertion_structures, primary_key: :stix_id, through: :stix_markings

  # remove audit is on the higher object, ie: the one the item is being removed from
  has_many :exploit_target_packages, primary_key: :stix_id, foreign_key: :stix_exploit_target_id
  has_many :stix_packages, through: :exploit_target_packages

  # remove audit is on the higher object, ie: the one the item is being removed from
  has_many :ttp_exploit_targets, primary_key: :stix_id, foreign_key: :stix_exploit_target_id
  has_many :ttps, through: :ttp_exploit_targets
  
  has_many :exploit_target_vulnerabilities, primary_key: :stix_id, foreign_key: :stix_exploit_target_id, dependent: :destroy
  has_many :vulnerabilities, through: :exploit_target_vulnerabilities, before_remove: :audit_vulnerability_removal

  has_many :exploit_target_course_of_actions, primary_key: :stix_id, foreign_key: :stix_exploit_target_id, dependent: :destroy
  has_many :course_of_actions, through: :exploit_target_course_of_actions, before_remove: :audit_course_of_action_removal

  has_many :badge_statuses, primary_key: :guid, as: :remote_object, dependent: :destroy

  belongs_to :created_by_user, class_name: 'User', primary_key: :guid, foreign_key: :created_by_user_guid
  belongs_to :updated_by_user, class_name: 'User', primary_key: :guid, foreign_key: :updated_by_user_guid
  belongs_to :created_by_organization, class_name: 'Organization', primary_key: :guid, foreign_key: :created_by_organization_guid
  belongs_to :updated_by_organization, class_name: 'Organization', primary_key: :guid, foreign_key: :updated_by_organization_guid

  belongs_to :acs_set, primary_key: :guid

  before_save :set_controlled_structures

  include AcsDefault
  include Auditable
  include Guidable
  include Stixable
  include Ingestible
  include Serialized
  include ClassifiedObject
  include Transferable

  CLASSIFICATION_CONTAINER_OF = [:course_of_actions, :vulnerabilities]

  CLASSIFICATION_CONTAINED_BY = [:stix_packages]

  # Trickles down the disseminated feed value to all of the associated objects
  def trickledown_feed
    begin
      associations = ["course_of_actions", "vulnerabilities"]
      associations.each do |a|
        object = self.send a
        if object.present? && self.feeds.present?
          object.each do |x| 
            x.update_column(:feeds, self.feeds) 
            x.try(:trickledown_feed)
          end 
        end
      end
    rescue Exception => e
      ex_msg = "Exception during trickledown_feed on: " + self.class.name    
      ExceptionLogger.debug("#{ex_msg}" + ". #{e.to_s}")
    end
  end         
    
    
  def self.ingest(uploader, obj, parent = nil)
    x = ExploitTarget.find_by_stix_id(obj.stix_id)
    if x.present? && uploader.overwrite == false && uploader.read_only == false
      IngestUtilities.add_warning(uploader, "Exploit Target of #{obj.stix_id} already exists.  Skipping.  Select overwrite to add")
      return x
    elsif uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite)
      if !obj.stix_id.nil?
        x = ExploitTarget.find_by_stix_id(obj.stix_id + Setting.READ_ONLY_EXT)
      end
    end

    if x.present?
      x.stix_markings.destroy_all
      x.exploit_target_vulnerabilities.destroy_all
      x.exploit_target_course_of_actions.destroy_all
      x.acs_set_id = nil
    end

    if x.present? && (uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite))
      x.destroy
      x = nil
    end

    x ||= ExploitTarget.new
    if (uploader.read_only || (Setting.CLASSIFICATION == true && uploader.overwrite)) && !obj.stix_id.nil?
      x.stix_id = obj.stix_id + Setting.READ_ONLY_EXT
      if (defined? obj.guid)  
        x.guid = obj.guid + Setting.READ_ONLY_EXT
      else 
        x.guid = SecureRandom.uuid + Setting.READ_ONLY_EXT
      end
    else 
      x.stix_id = obj.stix_id
    end
    x.stix_timestamp = obj.respond_to?(:stix_timestamp) ? obj.stix_timestamp : nil

    unless parent.nil?
      x.created_by_user_guid = parent.guid
      x.created_by_organization_guid = parent.organization_guid
      x.updated_by_user_guid = parent.guid
      x.updated_by_organization_guid = parent.organization_guid
    end

    x.read_only = uploader.read_only

    x
  rescue
    IngestUtilities.add_warning(uploader, "Failed to build Exploit Target (#{obj.stix_id})")
    x
  end

  def vulnerability_guids=(guids)
    self.vulnerability_ids = Vulnerability.where(guid: guids).pluck(:id)
  end

  def course_of_action_stix_ids=(stix_ids)
    self.course_of_action_ids = CourseOfAction.where(stix_id: stix_ids).pluck(:id)
  end

  def set_controlled_structures
    if self.stix_markings.present?
      self.stix_markings.each { |sm| set_controlled_structure(sm) }
    end
    set_vulnerability_controlled_structures
  end

  def set_controlled_structure(sm)
    if sm.present?
      sm.controlled_structure =
          "//stixCommon:Exploit_Target[@id='#{self.stix_id}']/"

      sm.controlled_structure += 'descendant-or-self::node()'
      sm.controlled_structure += " | #{sm.controlled_structure}/@*"
    end
  end

  def set_vulnerability_controlled_structures
    if self.vulnerabilities.present?
      self.vulnerabilities.each { |vn|
        if vn.stix_markings.present?
          vn.stix_markings.each { |sm|
            vn.set_controlled_structure(sm, self.stix_id)
          }
        end
      }
    end
  end


  def audit_vulnerability_removal(item)
    audit = Audit.basic
    audit.message = "Vulnerability '#{item.title}' removed Exploit Target '#{self.stix_id}'"
    audit.audit_type = :exploit_target_vulnerability_unlink
    ind_audit = audit.dup
    ind_audit.item = item
    item.audits << ind_audit
    ta_audit = audit.dup
    ta_audit.item = self
    self.audits << ta_audit
  end

  def audit_course_of_action_removal(item)
    audit = Audit.basic
    audit.message = "Course of Action '#{item.title}' removed Exploit Target '#{self.stix_id}'"
    audit.audit_type = :exploit_target_course_of_action_unlink
    ind_audit = audit.dup
    ind_audit.item = item
    item.audits << ind_audit
    ta_audit = audit.dup
    ta_audit.item = self
    self.audits << ta_audit
  end

private

  searchable :auto_index => (Setting.SOLR_INDEX_FREQUENCY_IN_SECONDS||0)==0 do
    text :stix_id, as: :text_exact
    string :stix_id
    text :guid, as: :text_exactm
    time :updated_at, stored: false
    time :created_at, stored: false

  end

end
