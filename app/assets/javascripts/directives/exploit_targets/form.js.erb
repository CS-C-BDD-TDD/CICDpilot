<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>

app.directive('exploitTargetForm',function() {
  return {
    restrict: 'E',
    scope: {
      exploitTarget: '=',
      save: '=',
      editform: '='
    },
    templateUrl: '<%=asset_path("exploit_targets/form.html",type: :template)%>',
    controller: ['$scope', '$rootScope', '$q', 'Restangular','ExploitTarget', '$location', 'Classification', 'exploitTargetService', function($scope, $rootScope,$q, Restangular, ExploitTarget, $location, Classification, exploitTargetService){
      $scope.can = $rootScope.can;
      $scope.ExploitTarget = ExploitTarget;
      $scope.sets = [];
      $scope.params = exploitTargetService.get_params() || {};

      if (angular.isDefined($scope.params.part_one)){
        $scope.part_one = $scope.params.part_one;
      } else {
        $scope.part_one = true;
      }

      if (angular.isDefined($scope.params.part_two)){
        $scope.part_two = $scope.params.part_two;
      } else {
        $scope.part_two = false;
      }

      if (angular.isDefined($scope.params.part_three)){
        $scope.part_three = $scope.params.part_three;
      } else {
        $scope.part_three = false;
      }

      $scope.added_vulnerabilities = [];
      $scope.cve_pattern = /^CVE-\d{4}-[0-9]+$/;
      $scope.positive_integer = /^\d+$/;

      var listener=$scope.$watch('exploitTarget',function(exploit_target) {
        if (angular.isDefined(exploit_target)) {
          listener();
          $scope.exploit_target = exploit_target;
          $scope.added_vulnerabilities = $scope.exploit_target.added_vulnerabilities || [];
        };
      });

      Restangular.one('acs_sets').get({organization_guid: $rootScope.current_user.organization.guid}).then(function(data){
          $scope.sets = data;
      },function(res){
          toastr.error("Unable to load ACS Set List");
      });
      
      $scope.to_vulnerability = function(exploit_target){
          //Clear all validation_error flag
         if(angular.isDefined($scope.exploit_target.vulnerabilities)) {
            _.forEach($scope.exploit_target.vulnerabilities, function(vulnerability) {
                    vulnerability.validation_error = false;
                })
            }
         if(angular.isDefined($scope.added_vulnerabilities)) {
            _.forEach($scope.added_vulnerabilities, function(new_vulnerability) {           
                new_vulnerability.validation_error = false;
            })
        }
        var orig_vul = exploit_target.vulnerabilities;
        exploit_target.vulnerabilities = exploit_target.vulnerabilities.concat($scope.added_vulnerabilities);
        Restangular.one('validate_classification/ExploitTarget').customPUT($scope.exploit_target).then(function(data){  
            exploit_target.vulnerabilities = orig_vul;
            $scope.part_one = !$scope.part_one;
            $scope.part_two = !$scope.part_two;
        },function(res){
            if (angular.isDefined(res.data) && angular.isDefined(res.data.errors) ){
                //parse error
                $scope.exploit_target = $rootScope.parse_error(res.data.errors, $scope.exploit_target);
                _.forEach($scope.exploit_target.vulnerabilities, function(vulnerability){
                    _.forEach($scope.added_vulnerabilities, function(new_vulnerability) {
                        if(new_vulnerability == vulnerability && vulnerability.validation_error) {
                            new_vulnerability.validation_error = true;
                        }
                    })
                })
                exploit_target.vulnerabilities = orig_vul; 
                $scope.part_one = !$scope.part_one;
                $scope.part_two = !$scope.part_two;
                toastr.error("Invalid Classification, Classification of the Vulnerability is greater than the classification of the Exploit Target containing this object");
                toastr.error("Please update vulnerabilities highlighted in red before continue");
            }
        });
      }
      
      $scope.back_vulnerability = function(exploit_target){
          $scope.part_three = !$scope.part_three; 
          $scope.part_two = !$scope.part_two;
      }
      
      $scope.to_coas = function(exploit_target){
        var orig_vul = exploit_target.vulnerabilities;
        exploit_target.vulnerabilities = exploit_target.vulnerabilities.concat($scope.added_vulnerabilities);

        var has_error = false;
        if($rootScope.is_undefined_or_null(exploit_target.vulnerabilities) || exploit_target.vulnerabilities.length == 0) {
            toastr.error("You have to have at the least one vulnerability");
            has_error = true;
        }
        
        if($scope.added_vulnerabilities.length) {
             _.forEach($scope.added_vulnerabilities, function(vulnerability) {
                 vulnerability.errors = {};
                 if($rootScope.is_undefined_or_null(vulnerability.osvdb_id) && $rootScope.is_undefined_or_null(vulnerability.cve_id) ){
                     if($rootScope.is_undefined_or_null(vulnerability.title)){
                      vulnerability.errors.title = [" can't be blank if cve_id or osvdb_id is not provided"];
                      has_error = true;
                   }
                 }
                 
                 if(vulnerability.description) {
                    if($rootScope.is_undefined_or_null(vulnerability.title)){
                        vulnerability.errors.title = [" can't be blank if description is defined"];
                        has_error = true;
                    }
                 }
                              
                 if(vulnerability.title) {
                    if($rootScope.is_undefined_or_null(vulnerability.description)){
                        vulnerability.errors.description = [" can't be blank if title is defined"];
                        has_error = true;
                    }
                 }
               
                 if (vulnerability.cve_id) {
                    if($rootScope.is_undefined_or_null(vulnerability.osvdb_id)){
                        vulnerability.errors.osvdb_id = [" can't be blank if CVE_ID is defined"];
                        has_error = true;
                    }
                    if(!$scope.cve_pattern.test(vulnerability.cve_id)){
                        vulnerability.errors.cve_id = [" must follow the pattern: CVE-<exactly four digits>â€”<one or more digits>"];
                        has_error = true;
                    }
                 }
                 
                 if(vulnerability.osvdb_id) {
                     if($rootScope.is_undefined_or_null(vulnerability.cve_id)){
                        vulnerability.errors.cve_id = [" can't be blank if OSVDB_ID is defined"];
                        has_error = true;
                    }
                     /*positive integer*/
                    if (!$scope.positive_integer.test(vulnerability.osvdb_id)){
                        vulnerability.errors.osvdb_id = [" must be positive integer"];
                        has_error = true;
                    }
                 }
             })
         }

        if(has_error){
            exploit_target.vulnerabilities = orig_vul;
        } else {
             //Clear all validation_error flag before validation
            if(angular.isDefined($scope.exploit_target.vulnerabilities)) {
                _.forEach($scope.exploit_target.vulnerabilities, function(vulnerability) {
                    vulnerability.validation_error = false;
                })
            }
            if(angular.isDefined($scope.added_vulnerabilities)) {
                _.forEach($scope.added_vulnerabilities, function(new_vulnerability) {           
                    new_vulnerability.validation_error = false;
                })
            }
            Restangular.one('validate_classification/ExploitTarget').customPUT($scope.exploit_target).then(function(data){
                exploit_target.vulnerabilities = orig_vul;
                $scope.part_two = !$scope.part_two;
                $scope.part_three = !$scope.part_three;   
            },function(res){
                $scope.exploit_target = $rootScope.parse_error(res.data.errors, $scope.exploit_target);
                _.forEach($scope.exploit_target.vulnerabilities, function(vulnerability){
                    _.forEach($scope.added_vulnerabilities, function(new_vulnerability) {
                        if(new_vulnerability == vulnerability && vulnerability.validation_error) {
                            new_vulnerability.validation_error = true;
                        }
                    })
                })
                exploit_target.vulnerabilities = orig_vul;
                toastr.error("Unable to go to next page due to classification error, please update vulnerabilities highlighted in red before continue");
                toastr.error("Invalid Classification, Classification of the Vulnerability is greater than the classification of the Exploit Target containing this object");
            });
         }
      }
      
      $scope.start_save = function(exploit_target){
        $scope.is_saving = true;
        $scope.part_three = false;
        $scope.part_one = true;
        $scope.exploit_target.errors = {};
        /*
        Rules for when CLASSIFICATION is true

        and ACS Set or Classification must be selected. When Classification is above unclassified, 
        details must be filled out.
        */
        if ($rootScope.setting_value('CLASSIFICATION') == true){
          $scope.exploit_target.stix_markings_attributes = Classification.check_classification_details($scope.exploit_target.stix_markings_attributes);
          var problems = $scope.exploit_target.stix_markings_attributes.problems;
          var classification_check = $scope.exploit_target.stix_markings_attributes.classification_check;
          /*
          If customized was not clicked and ISA Assertion Structure is not defined.
          In this case we need to make sure that an ACS Set is selected because an ACS Set is required to have a classification.
          */
          var obj_level_index = _.findIndex($scope.exploit_target.stix_markings_attributes, function(sm){
            return ($rootScope.is_undefined_or_null(sm.remote_object_field) || (angular.isDefined(sm.remote_object_field) && sm.remote_object_field == null)) && angular.isDefined(sm.isa_assertion_structure_attributes);
          })
          if (($rootScope.is_undefined_or_null($scope.exploit_target.stix_markings_attributes[obj_level_index]) || 
          $rootScope.is_undefined_or_null($scope.exploit_target.stix_markings_attributes[obj_level_index].isa_assertion_structure_attributes)) && $rootScope.is_undefined_or_null($scope.exploit_target.acs_set_id)) {
            $scope.exploit_target.errors.acs_set_id = ["You either need to associate an ACS Set or Click Customize and set a Classification"];
            if (angular.isDefined($scope.exploit_target.stix_markings_attributes[obj_level_index].isa_assertion_structure_attributes)){
              $scope.exploit_target.stix_markings_attributes[obj_level_index].isa_assertion_structure_attributes.errors.acs_set_id = ["You either need to associate an ACS Set or set a Classification"];
            }
            classification_check = true;
          }
        }
        if (Object.keys($scope.exploit_target.errors).length > 0 || classification_check) {
            $scope.is_saving = false;
            toastr.error("Unable to save Exploit Target");
            $("html, body").animate({ scrollTop: 0 }, 200);
            if(classification_check){
                for (var i = 0; i < problems.length; i++){
                    if(problems[i].field == null){
                        toastr.error("Unable to save due to classification errors in the Object level markings");
                    } else {
                        toastr.error("Unable to save due to classification errors in the " + problems[i].field + " markings");
                    }
                };
            }
            return;
        }
        
        /*create new vulnerabilities first*/    
        if($scope.added_vulnerabilities.length) {
           var result = [];
           var promiseArr = [];
             for(i=0; i < $scope.added_vulnerabilities.length; i++) {
                 var new_vulnerability = $scope.added_vulnerabilities[i];
                 
                 /*
                Rules for when CLASSIFICATION is true

                and ACS Set or Classification must be selected. When Classification is above unclassified, 
                details must be filled out.
                */
                if ($rootScope.setting_value('CLASSIFICATION') == true){
                    new_vulnerability.stix_markings_attributes = Classification.check_classification_details(new_vulnerability.stix_markings_attributes);
                    var problems = new_vulnerability.stix_markings_attributes.problems;
                    var classification_check = new_vulnerability.stix_markings_attributes.classification_check;
                }
                if (Object.keys(new_vulnerability.errors).length > 0 || classification_check) {
                    $scope.is_saving = false;
                    toastr.error("Unable to save Vulnerability");
                    $("html, body").animate({ scrollTop: 0 }, 200);
                    if(classification_check){
                        for (var i = 0; i < problems.length; i++){
                            if(problems[i].field == null){
                                toastr.error("Unable to save due to classification errors in the Object level markings");
                            } else {
                                toastr.error("Unable to save due to classification errors in the " + problems[i].field + " markings");
                            }
                        }
                    }
                    return;
                }

                result[i] = Restangular.all('vulnerabilities').post(new_vulnerability);
                promiseArr.push(result[i]);
                result[i].then(function(res){ 
                        if (! angular.isDefined($scope.exploit_target.vulnerabilities)) {
                            $scope.exploit_target.vulnerabilities = [];
                        } 
                        $scope.exploit_target.vulnerabilities.push(res);
                        var vul_index = _.findIndex($scope.added_vulnerabilities, function(vul) { return (res.title == vul.title && res.description == vul.description) || (res.cve_id == vul.cve_id && res.osvdb_id == vul.osvdb_id) })
                        if(vul_index >= 0) {
                            $scope.added_vulnerabilities.splice(vul_index,1); 
                        }     
                    },function(res){
                        toastr.error("Unable to save vulnerability");
                        if (angular.isDefined(res.data) && angular.isDefined(res.data.errors)) {
                            $scope.exploit_target.errors = res.data.errors;
                            if(angular.isDefined(res.data.errors.base)) {
                                _.each(res.data.errors.base,function(e){
                                    toastr.error(e);
                                });
                            }
                        }
                        
                        $scope.is_saving=false;
                   })
            }; 
            
            $q.all(promiseArr).then(function(res){
                $scope.save(exploit_target, function(){
                    $scope.is_saving = false;
                })
            })          
        }else {
            $scope.save(exploit_target, function(){
                $scope.is_saving = false;
         });
        }
      };

      $scope.show_browser = false;

      $scope.cancel = function() {
        if (angular.isDefined($scope.exploit_target.stix_id)){
          $location.path('/exploit_targets/' + $scope.exploit_target.stix_id);
        } else {
          $location.path('/exploit_targets');
        }
      };
      $scope.toggle_browser = function(){
        $scope.show_browser = !$scope.show_browser;
      };
      
      $scope.add_vulnerability = function(){
          $scope.added_vulnerabilities.push({title: "", description: ""});
          
          var vul_length = $scope.added_vulnerabilities.length;
      };

      $scope.remove_vulnerability = function(vulnerability){
          _.remove($scope.added_vulnerabilities, function(f){
            return f == vulnerability;
          })
        };


      $scope.removeVulnerability = function(vulnerability) {
        _.remove($scope.exploit_target.vulnerabilities, function(exploit_target_vulnerability){
          if (exploit_target_vulnerability == vulnerability) {
            return exploit_target_vulnerability;
          }
        });
      };
      
      $scope.editVulnerability = function(vulnerability) {
        $scope.exploit_target.added_vulnerabilities = $scope.added_vulnerabilities;
        exploitTargetService.set_data($scope.exploit_target);
        exploitTargetService.set_params({part_one: $scope.part_one, part_two: $scope.part_two, part_three: $scope.part_three});

        $location.path('/vulnerabilities/' + vulnerability.guid + "/edit");
      };
      
      $scope.removeCourseOfAction = function(coa) {
        _.remove($scope.exploit_target.course_of_actions, function(i){
          if (i == coa) {
            return i;
          }
        });
      };

    }]
  };
});
